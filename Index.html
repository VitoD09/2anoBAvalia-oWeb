<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Epic Boss Fight Mobile Fix</title>
  <style>
    body {
      margin: 0;
      background: #050505;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: 'Courier New', Courier, monospace;
      user-select: none;
      -webkit-user-select: none; /* Safari */
      touch-action: none; /* ESSENCIAL PARA MOBILE: Bloqueia zoom/scroll nativo */
    }
    canvas {
      image-rendering: pixelated;
      box-shadow: 0 0 20px rgba(0,0,0,0.8);
      background-color: #1a1a1a;
      touch-action: none;
    }
    #loading {
      position: absolute;
      color: white;
      font-size: 20px;
      z-index: 10;
      background: rgba(0,0,0,0.9);
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      text-align: center;
    }
    .btn-start {
      margin-top: 20px;
      padding: 15px 30px;
      background: #444;
      color: #fff;
      border: 2px solid #fff;
      font-family: inherit;
      font-size: 24px;
      cursor: pointer;
      display: none; /* Aparece só quando carregar */
    }
    .btn-start:active { background: #666; }
  </style>
</head>
<body>

  <div id="loading">
    <div id="loadText">Carregando Assets...</div>
    <button id="startBtn" class="btn-start">TOCAR PARA INICIAR</button>
  </div>
  
  <canvas id="gameCanvas"></canvas>

<script>
/**
 * =========================================================
 * CONFIGURAÇÃO E ASSETS
 * =========================================================
 */
const ASSETS = {
  knight: "https://files.catbox.moe/82ol9c.png",
  knightAtk: "https://files.catbox.moe/fietvv.png",
  goblin: "https://files.catbox.moe/axp8rl.png",
  goblinAtk: "https://files.catbox.moe/wy3kh2.png",
  bg: "https://files.catbox.moe/s1ywcn.png"
};

const CONFIG = {
  GRAVITY: 1200,
};

class AudioManager {
  constructor() {
    this.ctx = null;
    this.enabled = false;
  }
  
  init() {
    // Inicializa apenas após interação do usuário (Regra de Mobile)
    if (!this.ctx) {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.enabled = true;
    } else if (this.ctx.state === 'suspended') {
        this.ctx.resume();
    }
  }

  playTone(freq, type, duration, vol = 0.1) {
    if (!this.enabled || !this.ctx) return;
    try {
      const osc = this.ctx.createOscillator();
      const gain = this.ctx.createGain();
      osc.type = type;
      osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
      gain.gain.setValueAtTime(vol, this.ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
      osc.connect(gain);
      gain.connect(this.ctx.destination);
      osc.start();
      osc.stop(this.ctx.currentTime + duration);
    } catch(e) {}
  }
  playJump() { this.playTone(300, 'square', 0.1, 0.05); }
  playHit() { this.playTone(100, 'sawtooth', 0.2, 0.1); }
  playDash() { this.playTone(600, 'sine', 0.15, 0.05); }
  playSelect() { this.playTone(800, 'square', 0.05, 0.05); }
}

class InputHandler {
  constructor() {
    this.keys = {};
    // DETECÇÃO DE MOBILE MELHORADA
    this.isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
    this.virtualInput = { up: false, left: false, right: false, attack: false, dash: false };

    window.addEventListener('keydown', e => this.keys[e.key.toLowerCase()] = true);
    window.addEventListener('keyup', e => this.keys[e.key.toLowerCase()] = false);

    // Sempre tenta configurar o touch se o navegador suportar, independente do user agent
    if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
        this.setupTouch();
        this.isMobile = true; // Força flag mobile
    }
  }

  setupTouch() {
    const canvas = document.querySelector('canvas');
    this.touchButtons = [
      { id: 'left', x: 0, y: 0, r: 50, active: false },
      { id: 'right', x: 0, y: 0, r: 50, active: false },
      { id: 'up', x: 0, y: 0, r: 50, active: false, label: 'PULO' },
      { id: 'attack', x: 0, y: 0, r: 60, active: false, label: 'ATK' },
      { id: 'dash', x: 0, y: 0, r: 40, active: false, label: 'DASH' }
    ];

    const handleTouch = (e) => {
      // Impede comportamento padrão (scroll/zoom)
      if (e.cancelable) e.preventDefault();
      
      this.touchButtons.forEach(b => b.active = false);
      this.virtualInput = { up: false, left: false, right: false, attack: false, dash: false };

      for (let i = 0; i < e.touches.length; i++) {
        const t = e.touches[i];
        const rect = canvas.getBoundingClientRect();
        
        // Coordenadas relativas ao canvas
        const cx = (t.clientX - rect.left) * (canvas.width / rect.width);
        const cy = (t.clientY - rect.top) * (canvas.height / rect.height);

        this.touchButtons.forEach(btn => {
          const dx = cx - btn.x;
          const dy = cy - btn.y;
          // Hitbox 50% maior que o desenho visual para facilitar o toque
          if (dx*dx + dy*dy < (btn.r * 1.5) * (btn.r * 1.5)) {
            btn.active = true;
            this.virtualInput[btn.id] = true;
          }
        });
      }
    };

    canvas.addEventListener('touchstart', handleTouch, {passive: false});
    canvas.addEventListener('touchmove', handleTouch, {passive: false});
    canvas.addEventListener('touchend', handleTouch, {passive: false});
    canvas.addEventListener('touchcancel', handleTouch, {passive: false});
  }

  updateLayout(width, height) {
    if (!this.isMobile) return;
    const padding = 20;
    
    // Controles Esquerda (Movimento)
    this.touchButtons[0].x = 70; // Left
    this.touchButtons[0].y = height - 70;
    
    this.touchButtons[1].x = 190; // Right
    this.touchButtons[1].y = height - 70;
    
    // Controles Direita (Ação)
    this.touchButtons[3].x = width - 80; // Attack (O mais importante, bem na ponta)
    this.touchButtons[3].y = height - 80;
    
    this.touchButtons[2].x = width - 200; // Jump (Um pouco para dentro)
    this.touchButtons[2].y = height - 60;
    
    this.touchButtons[4].x = width - 90; // Dash (Acima do ataque)
    this.touchButtons[4].y = height - 200;
  }

  isDown(action) {
    if (this.isMobile) return this.virtualInput[action];
    
    switch(action) {
      case 'left': return this.keys['a'] || this.keys['arrowleft'];
      case 'right': return this.keys['d'] || this.keys['arrowright'];
      case 'up': return this.keys['w'] || this.keys['arrowup'] || this.keys[' '];
      case 'attack': return this.keys['enter'] || this.keys['z'] || this.keys['k'];
      case 'dash': return this.keys['shift'] || this.keys['l'];
    }
    return false;
  }

  draw(ctx) {
    if (!this.isMobile) return;
    ctx.save();
    ctx.globalAlpha = 0.5;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = "bold 16px Arial";
    
    this.touchButtons.forEach(b => {
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
      ctx.fillStyle = b.active ? "rgba(255, 255, 255, 0.8)" : "rgba(100, 100, 100, 0.5)";
      ctx.fill();
      ctx.strokeStyle = "white";
      ctx.lineWidth = 3;
      ctx.stroke();
      
      if(b.label) {
        ctx.fillStyle = b.active ? "black" : "white";
        ctx.fillText(b.label, b.x, b.y);
      } else {
        // Setas para esquerda/direita
        ctx.fillStyle = b.active ? "black" : "white";
        ctx.fillText(b.id === 'left' ? '<' : '>', b.x, b.y);
      }
    });
    ctx.restore();
  }
}

class Camera {
  constructor(width, height) {
    this.x = 0; this.y = 0;
    this.width = width; this.height = height;
    this.shakeStrength = 0;
  }
  follow(target, mapWidth, mapHeight) {
    let targetX = target.x + target.width / 2 - this.width / 2;
    let targetY = target.y + target.height / 2 - this.height / 2;
    this.x += (targetX - this.x) * 0.1;
    this.y += (targetY - this.y) * 0.1;
    this.x = Math.max(0, Math.min(this.x, mapWidth - this.width));
    this.y = Math.max(0, Math.min(this.y, mapHeight - this.height));
    if (this.shakeStrength > 0) {
      this.shakeStrength *= 0.9;
      if(this.shakeStrength < 0.5) this.shakeStrength = 0;
    }
  }
  shake(amount) { this.shakeStrength = amount; }
  apply(ctx) {
    const dx = (Math.random() - 0.5) * this.shakeStrength;
    const dy = (Math.random() - 0.5) * this.shakeStrength;
    ctx.translate(-this.x + dx, -this.y + dy);
  }
}

class Entity {
  constructor(x, y, w, h) {
    this.x = x; this.y = y; this.width = w; this.height = h;
    this.vx = 0; this.vy = 0;
    this.grounded = false;
    this.facingRight = true;
    this.hitFlashTimer = 0;
  }
  applyPhysics(dt, platforms) {
    this.vy += CONFIG.GRAVITY * dt;
    this.x += this.vx * dt;
    this.y += this.vy * dt;
    this.grounded = false;
    for (let p of platforms) {
      if (this.x < p.x + p.w && this.x + this.width > p.x &&
          this.y < p.y + p.h && this.y + this.height > p.y) {
        if (this.vy > 0 && this.y + this.height - (this.vy * dt) <= p.y + 15) { // Margem aumentada para estabilidade
          this.y = p.y - this.height;
          this.vy = 0;
          this.grounded = true;
        } else if (this.y + this.height > p.y + 5) {
           if (this.vx > 0) this.x = p.x - this.width;
           else if (this.vx < 0) this.x = p.x + p.w;
           this.vx = 0;
        }
      }
    }
  }
  takeDamage(amount) { this.hitFlashTimer = 0.2; }
  draw(ctx, sprite, frame, sx, sy, sw, sh) {
    ctx.save();
    if (this.hitFlashTimer > 0) {
      ctx.globalCompositeOperation = "source-atop";
      ctx.filter = "brightness(1000%)";
    }
    
    if (sprite && sprite.complete && sprite.naturalWidth !== 0) {
        if (!this.facingRight) {
            ctx.translate(this.x + this.width, this.y);
            ctx.scale(-1, 1);
            ctx.drawImage(sprite, sx, sy, sw, sh, 0, 0, this.width, this.height);
        } else {
            ctx.drawImage(sprite, sx, sy, sw, sh, this.x, this.y, this.width, this.height);
        }
    } else {
        ctx.fillStyle = this instanceof Player ? 'blue' : 'green';
        ctx.fillRect(this.x, this.y, this.width, this.height);
    }
    
    ctx.restore();
    this.hitFlashTimer = Math.max(0, this.hitFlashTimer - 0.016);
  }
}

class Player extends Entity {
  constructor(x, y) {
    super(x, y, 60, 270);
    this.speed = 300;
    this.jumpForce = -750;
    this.hp = 100;
    this.maxHp = 100;
    this.state = 'idle';
    this.animTimer = 0;
    this.currentFrame = 0;
    this.attackCooldown = 0;
    this.isAttacking = false;
    this.dashCooldown = 0;
    this.dashTimer = 0;
    this.dashSpeed = 800;
  }
  update(dt, input, platforms, enemies, audio, particles) {
    if (this.dashCooldown > 0) this.dashCooldown -= dt;
    if (this.attackCooldown > 0) this.attackCooldown -= dt;

    if (this.state === 'dash') {
      this.dashTimer -= dt;
      this.vx = (this.facingRight ? 1 : -1) * this.dashSpeed;
      this.vy = 0;
      if (Math.random() < 0.5) particles.create(this.x + this.width/2, this.y + this.height, '#fff', 20);
      if (this.dashTimer <= 0) { this.state = 'idle'; this.vx = 0; }
    } else {
      this.vx = 0;
      if (!this.isAttacking) {
        if (input.isDown('left')) { this.vx = -this.speed; this.facingRight = false; }
        if (input.isDown('right')) { this.vx = this.speed; this.facingRight = true; }
        if (input.isDown('up') && this.grounded) {
          this.vy = this.jumpForce;
          audio.playJump();
          for(let i=0; i<5; i++) particles.create(this.x + 30, this.y + 270, '#aaa', 30);
        }
      }
      if (input.isDown('dash') && this.dashCooldown <= 0) {
        this.state = 'dash';
        this.dashTimer = 0.2;
        this.dashCooldown = 1.0;
        this.isAttacking = false;
        audio.playDash();
      }
      if (input.isDown('attack') && !this.isAttacking && this.attackCooldown <= 0) {
        this.isAttacking = true;
        this.currentFrame = 0;
        this.animTimer = 0;
        this.attackCooldown = 0.4;
      }
    }
    this.applyPhysics(dt, platforms);

    if (this.state !== 'dash') {
      if (this.isAttacking) {
        this.state = 'attack';
        if (this.currentFrame === 2 || this.currentFrame === 3) this.checkAttackHit(enemies, audio, particles);
      } else if (!this.grounded) {
        this.state = 'jump';
      } else if (Math.abs(this.vx) > 10) {
        this.state = 'run';
      } else {
        this.state = 'idle';
      }
    }

    this.animTimer += dt * 1000;
    let limitFrames = (this.state === 'attack') ? 6 : 6;
    let speed = (this.state === 'attack') ? 80 : 100;
    if (this.animTimer > speed) {
      this.animTimer = 0;
      this.currentFrame++;
      if (this.currentFrame >= limitFrames) {
        if (this.isAttacking) { this.isAttacking = false; this.state = 'idle'; }
        this.currentFrame = 0;
      }
    }
  }
  checkAttackHit(enemies, audio, particles) {
    const reach = 100;
    const hitX = this.facingRight ? this.x + this.width : this.x - reach;
    const hitBox = { x: hitX, y: this.y + 50, w: reach, h: 150 };
    enemies.forEach(e => {
      if (e.dead) return;
      if (hitBox.x < e.x + e.width && hitBox.x + hitBox.w > e.x &&
          hitBox.y < e.y + e.height && hitBox.y + hitBox.h > e.y) {
            e.takeDamage(10);
            audio.playHit();
            for(let i=0; i<8; i++) particles.create(e.x + e.width/2, e.y + e.height/2, '#ff0000', 40, true);
      }
    });
  }
  render(ctx, assets) {
    let sprite = assets.knight;
    let sx = 40, sy = 10, sw = 20, sh = 90;
    if (this.state === 'attack') {
      sprite = assets.knightAtk;
      sx = 25; sy = 10; sw = 50; sh = 90;
    }
    this.draw(ctx, sprite, this.currentFrame, this.currentFrame * 100 + sx, sy, sw, sh);
    if (this.grounded) {
      ctx.fillStyle = "rgba(0,0,0,0.5)";
      ctx.beginPath();
      ctx.ellipse(this.x + 30, this.y + 265, 20, 5, 0, 0, Math.PI*2);
      ctx.fill();
    }
  }
}

class Enemy extends Entity {
  constructor(x, y, type) {
    super(x, y, 30 * 5, 40 * 5);
    this.type = type;
    this.hp = type === 'boss' ? 200 : 30;
    this.maxHp = this.hp;
    this.dead = false;
    this.state = 'idle';
    this.animTimer = 0;
    this.frame = 0;
    this.atkTimer = 0;
  }
  update(dt, player, platforms, game) {
    if (this.dead) return;
    const dist = Math.abs((player.x + player.width/2) - (this.x + this.width/2));
    const range = this.type === 'boss' ? 800 : 400;
    const atkRange = 150;

    if (dist < range) {
      this.facingRight = player.x > this.x;
      if (dist > atkRange - 20) {
        this.vx = (this.facingRight ? 1 : -1) * (this.type === 'boss' ? 100 : 50);
        this.state = 'walk';
      } else {
        this.vx = 0;
        this.state = 'idle';
        this.atkTimer += dt;
        if (this.atkTimer > (this.type === 'boss' ? 2 : 3)) {
          this.state = 'attack';
          this.frame = 0;
          this.atkTimer = 0;
        }
      }
    } else { this.vx = 0; this.state = 'idle'; }

    if (this.state === 'attack') {
      this.vx = 0;
      if (this.frame === 4 && !this.hasDealtDamage) {
        if (dist < atkRange) {
          player.takeDamage(15);
          game.camera.shake(10);
          player.vx = (player.x > this.x ? 1 : -1) * 400;
          player.vy = -200;
        }
        this.hasDealtDamage = true;
      }
    } else { this.hasDealtDamage = false; }

    this.applyPhysics(dt, platforms);
    this.animTimer += dt * 1000;
    const limit = (this.state === 'attack') ? 6 : 4;
    const interval = (this.state === 'attack') ? 100 : 150;
    if (this.animTimer > interval) {
      this.animTimer = 0;
      this.frame++;
      if (this.frame >= limit) {
        if (this.state === 'attack') this.state = 'idle';
        this.frame = 0;
      }
    }
  }
  takeDamage(amt) {
    super.takeDamage(amt);
    this.hp -= amt;
    if (this.hp <= 0) this.dead = true;
  }
  render(ctx, assets) {
    if (this.dead) return;
    let sprite = assets.goblin;
    let sx = 35, sy = 30, sw = 30, sh = 40;
    let qw = 100;
    if (this.state === 'attack') {
      sprite = assets.goblinAtk;
      sx = 40; sy = 20; sw = 30; sh = 40;
    }
    this.draw(ctx, sprite, this.frame, this.frame * qw + sx, sy, sw, sh);
    if (this.hp < this.maxHp) {
      ctx.fillStyle = 'red';
      ctx.fillRect(this.x, this.y - 20, this.width, 5);
      ctx.fillStyle = '#0f0';
      ctx.fillRect(this.x, this.y - 20, this.width * (this.hp/this.maxHp), 5);
    }
  }
}

class ParticleSystem {
  constructor() { this.pool = []; }
  create(x, y, color, size, gravity=false) {
    this.pool.push({x, y, c: color, s: Math.random()*size + 5, l: 1.0, vx: (Math.random()-0.5)*200, vy: (Math.random()-0.5)*200, g: gravity});
  }
  updateAndDraw(ctx, dt) {
    for (let i = this.pool.length - 1; i >= 0; i--) {
      let p = this.pool[i];
      p.l -= dt * 2;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      if(p.g) p.vy += 500 * dt;
      if (p.l <= 0) { this.pool.splice(i, 1); } else {
        ctx.globalAlpha = p.l;
        ctx.fillStyle = p.c;
        ctx.fillRect(p.x, p.y, p.s, p.s);
      }
    }
    ctx.globalAlpha = 1.0;
  }
}

class Game {
  constructor() {
    this.canvas = document.getElementById('gameCanvas');
    this.ctx = this.canvas.getContext('2d');
    this.state = 'LOADING'; // Estado inicial de carregamento
    this.lastTime = 0;
    this.audio = new AudioManager();
    this.input = new InputHandler();
    this.camera = new Camera(this.canvas.width, this.canvas.height);
    this.particles = new ParticleSystem();
    this.currentLevel = 0;
    this.levels = [
      { w: 2000, h: 600, platforms: [{x: 0, y: 500, w: 2000, h: 100}, {x: 400, y: 350, w: 200, h: 20}, {x: 800, y: 250, w: 200, h: 20}, {x: 1200, y: 350, w: 200, h: 20}], enemies: [{x: 900, y: 150, type: 'minion'}] },
      { w: 1200, h: 600, platforms: [{x: 0, y: 500, w: 1200, h: 100}, {x: 0, y: 0, w: 50, h: 600}, {x: 1150, y: 0, w: 50, h: 600}], enemies: [{x: 800, y: 300, type: 'boss'}] }
    ];
    this.images = {};
    this.assetsLoaded = 0;
    this.totalAssets = Object.keys(ASSETS).length;
    
    // Configura o botão de start
    const startBtn = document.getElementById('startBtn');
    startBtn.onclick = () => {
        this.audio.init(); // Inicializa áudio no clique
        document.getElementById('loading').style.display = 'none';
        
        // Tenta fullscreen se estiver no mobile
        if(this.input.isMobile && document.documentElement.requestFullscreen) {
            document.documentElement.requestFullscreen().catch(e => console.log(e));
        }

        this.initMenu();
        requestAnimationFrame(t => this.loop(t));
    };

    this.resize();
    this.loadAssets();
    window.addEventListener('resize', () => this.resize());
  }

  resize() {
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
    if(this.camera) { this.camera.width = this.canvas.width; this.camera.height = this.canvas.height; }
    if(this.input) this.input.updateLayout(this.canvas.width, this.canvas.height);
  }

  loadAssets() {
    const checkStart = () => {
      this.assetsLoaded++;
      document.getElementById('loadText').innerText = `Carregando... ${Math.floor((this.assetsLoaded/this.totalAssets)*100)}%`;
      if (this.assetsLoaded >= this.totalAssets) {
        // Mostra botão de start ao invés de iniciar direto
        document.getElementById('loadText').style.display = 'none';
        document.getElementById('startBtn').style.display = 'block';
      }
    };

    for (let key in ASSETS) {
      const img = new Image();
      img.src = ASSETS[key];
      img.onload = checkStart;
      img.onerror = () => { console.log("Erro loading " + key); checkStart(); };
      this.images[key] = img;
    }
  }

  initMenu() {
    this.state = 'MENU';
    this.menuOptions = ['JOGAR', 'CONTROLES', 'CRÉDITOS'];
    this.menuIndex = 0;
  }
  startLevel(index) {
    this.currentLevel = index;
    const lvl = this.levels[index];
    this.player = new Player(100, 200);
    this.enemies = lvl.enemies.map(e => new Enemy(e.x, e.y, e.type));
    this.platforms = lvl.platforms;
    this.mapW = lvl.w;
    this.mapH = lvl.h;
    this.state = 'PLAY';
  }
  update(dt) {
    if (this.state === 'MENU') {
      // Input de teclado
      if (this.input.isDown('up') && !this.keyLock) { this.menuIndex--; this.keyLock = true; this.audio.playSelect(); }
      if (this.input.isDown('attack') && !this.keyLock) { this.keyLock = true; this.handleMenuSelect(); }
      
      // Input de Touch Direto para o Menu (Toque na tela central = Select)
      if (this.input.isMobile && (this.input.virtualInput.attack || this.input.virtualInput.up)) {
         if(!this.keyLock) { this.keyLock = true; this.handleMenuSelect(); }
      }
      
      if (!this.input.isDown('up') && !this.input.isDown('attack')) this.keyLock = false;
      if (this.menuIndex < 0) this.menuIndex = this.menuOptions.length - 1;
      this.menuIndex %= this.menuOptions.length;
      return;
    }
    if (this.state === 'PLAY') {
      this.player.update(dt, this.input, this.platforms, this.enemies, this.audio, this.particles);
      this.enemies.forEach(e => e.update(dt, this.player, this.platforms, this));
      this.camera.follow(this.player, this.mapW, this.mapH);
      if (this.currentLevel === 0 && this.player.x > this.mapW - 100) this.startLevel(1);
      if (this.player.hp <= 0) this.state = 'GAMEOVER';
      if (this.currentLevel === 1 && this.enemies.every(e => e.dead)) setTimeout(() => this.state = 'VICTORY', 1000);
    } else if (this.state === 'GAMEOVER' || this.state === 'VICTORY') {
      if (this.input.isDown('attack')) this.initMenu();
    }
  }
  handleMenuSelect() {
    if (this.menuIndex === 0) this.startLevel(0);
    if (this.menuIndex === 1) alert("PC: WASD Move, Enter Ataca, Shift Dash.\nMobile: Botões na tela.");
    if (this.menuIndex === 2) alert("Criado com Gemini AI");
  }
  draw() {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    if (this.state === 'MENU') {
      this.ctx.fillStyle = '#111';
      this.ctx.fillRect(0,0,this.canvas.width, this.canvas.height);
      this.ctx.fillStyle = 'white';
      this.ctx.font = '40px Courier New';
      this.ctx.textAlign = 'center';
      this.ctx.fillText("BOSS FIGHT: REMASTERED", this.canvas.width/2, 100);
      this.ctx.font = '24px Courier New';
      this.menuOptions.forEach((opt, i) => {
        this.ctx.fillStyle = i === this.menuIndex ? '#ff0' : '#888';
        this.ctx.fillText(opt, this.canvas.width/2, 250 + i * 50);
      });
      if(this.input.isMobile) {
          this.ctx.font = "16px Arial";
          this.ctx.fillStyle = "#aaa";
          this.ctx.fillText("(Toque em ATK para selecionar)", this.canvas.width/2, this.canvas.height - 50);
          this.input.draw(this.ctx); // Desenha controles no menu também para testar
      }
      return;
    }
    this.ctx.save();
    this.camera.apply(this.ctx);
    
    if(this.images.bg && this.images.bg.complete && this.images.bg.naturalWidth) {
        this.ctx.drawImage(this.images.bg, 0, 0, this.mapW, this.mapH);
    } else {
        this.ctx.fillStyle = '#222';
        this.ctx.fillRect(0,0, this.mapW, this.mapH);
    }

    this.ctx.fillStyle = '#2b2b2b';
    this.platforms.forEach(p => {
      this.ctx.fillRect(p.x, p.y, p.w, p.h);
      this.ctx.fillStyle = '#3a5e29';
      this.ctx.fillRect(p.x, p.y, p.w, 10);
      this.ctx.fillStyle = '#2b2b2b';
    });
    this.enemies.forEach(e => e.render(this.ctx, this.images));
    this.player.render(this.ctx, this.images);
    this.particles.updateAndDraw(this.ctx, 0.016);
    this.ctx.restore();
    this.drawUI();
    this.input.draw(this.ctx);
    if (this.state === 'GAMEOVER') this.drawOverlay("VOCÊ MORREU", "Aperte Atacar para reiniciar");
    if (this.state === 'VICTORY') this.drawOverlay("VITÓRIA!", "O Goblin Rei caiu.");
  }
  drawUI() {
    this.ctx.fillStyle = 'black';
    this.ctx.fillRect(20, 20, 204, 24);
    this.ctx.fillStyle = 'red';
    this.ctx.fillRect(22, 22, 200 * (Math.max(0,this.player.hp)/100), 20);
    this.ctx.strokeStyle = 'white';
    this.ctx.lineWidth = 2;
    this.ctx.strokeRect(20, 20, 204, 24);
    if(this.player.dashCooldown > 0) {
      this.ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
      this.ctx.fillRect(20, 50, 200 * (this.player.dashCooldown), 5);
    }
  }
  drawOverlay(title, sub) {
    this.ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.fillStyle = "white";
    this.ctx.font = "50px Courier New";
    this.ctx.textAlign = "center";
    this.ctx.fillText(title, this.canvas.width / 2, this.canvas.height / 2);
    this.ctx.font = "20px Courier New";
    this.ctx.fillText(sub, this.canvas.width / 2, this.canvas.height / 2 + 50);
  }
  loop(timestamp) {
    const dt = Math.min((timestamp - this.lastTime) / 1000, 0.1);
    this.lastTime = timestamp;
    this.update(dt);
    this.draw();
    requestAnimationFrame(t => this.loop(t));
  }
}

const game = new Game();
</script>
</body>
</html>